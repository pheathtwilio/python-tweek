<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Super Simple Video Test Harness</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    .row { display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-start; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; max-width: 720px; }
    video { width: 480px; max-width: 100%; border-radius: 12px; background: #000; display: block; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #cbd5e1; background: white; cursor: pointer; }
    .row button { min-width: 120px; }
    .muted { color: #64748b; font-size: 12px; }
    label { display:block; margin-top: 12px; }
    input[type=text]{ width: 320px; padding: 8px; }
    .grid { display: grid; gap: 12px; grid-template-columns: 1fr; }
    .kv { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    pre#serverLog { margin-top: 12px; border: 1px solid #e5e7eb; padding: 8px; border-radius: 8px; max-height: 220px; overflow: auto; background:#fafafa; }
  </style>
</head>
<body>
  <h1>Super Simple Video Test Harness</h1>

  <div class="card grid">
    <div class="row" style="gap:12px;margin-bottom:12px;">
      <button id="btnStart">Start</button>
      <button id="btnStop" disabled>Stop</button>
      <button id="btnMute" disabled>Mute Audio</button>
      <button id="btnHide" disabled>Hide Video</button>
    </div>

    <div class="kv">
      <label for="sessionId">Session ID</label>
      <input id="sessionId" type="text" placeholder="auto-generatedâ€¦" />
    </div>

    <div class="kv">
      <label for="audioLen">Audio chunk (ms)</label>
      <input id="audioLen" type="text" value="1000" />
      <label for="videoLen" style="margin-left:8px;">Video chunk (ms)</label>
      <input id="videoLen" type="text" value="1000" />
    </div>

    <video id="preview" autoplay playsinline muted></video>
    <p class="muted">
      Uses <code>Twilio.Video.createLocalTracks()</code> to get tracks, then <code>MediaRecorder</code> to POST chunks to the Python server. Server replies for this session arrive over <code>WebSocket</code> and are shown below.
    </p>

    <pre id="serverLog">Server messages:
</pre>
  </div>

  <!-- Twilio Video SDK (v2.32.1) -->
  <script src="https://sdk.twilio.com/js/video/releases/2.32.1/twilio-video.min.js"></script>

  <script>
    // Same-origin base 
    const serverBase = "";

    let localAudioTrack, localVideoTrack;
    let audioRecorder, videoRecorder;
    let audioStream, videoStream;
    let isMuted = false, isHidden = false;
    let ws;

    const $  = (id) => document.getElementById(id);
    const btnStart = $("btnStart");
    const btnStop  = $("btnStop");
    const btnMute  = $("btnMute");
    const btnHide  = $("btnHide");
    const preview  = $("preview");
    const sessionIdInput = $("sessionId");
    const serverLog = $("serverLog");
    const audioLenInput = $("audioLen");
    const videoLenInput = $("videoLen");

    const uuid = () => {
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    if (!sessionIdInput.value) sessionIdInput.value = uuid();

    const logServer = (msg) => {
      console.log(msg);
      const ts = new Date().toISOString().split("T")[1].replace("Z", "");
      serverLog.textContent += `[${ts}] ${msg}\n`;
      serverLog.scrollTop = serverLog.scrollHeight;
    }

    const connectWS = (sid) => {
      const proto = location.protocol === "https:" ? "wss" : "ws";
      ws = new WebSocket(`${proto}://${location.host}/ws?sid=${encodeURIComponent(sid)}`);
      ws.onopen = () => console.log("WS connected for sid:", sid);
      ws.onmessage = (event) => {
        console.log("Server - client:", event.data);
        logServer(event.data);
      };
      ws.onclose = () => console.log("WS closed");
      ws.onerror = (e) => console.warn("WS error", e);
    }

    const start = async () => {
      try {
        btnStart.disabled = true;

        // Create/get sid and connect WS first, so server can respond to early uploads
        const sid = sessionIdInput.value || uuid();
        sessionIdInput.value = sid;
        connectWS(sid);

        // Create local tracks via Twilio Video SDK
        const tracks = await Twilio.Video.createLocalTracks({
          audio: true,
          video: { width: 1280, height: 720, frameRate: 30 }
        });

        localAudioTrack = tracks.find(t => t.kind === "audio");
        localVideoTrack = tracks.find(t => t.kind === "video");

        // Preview stream
        const previewStream = new MediaStream();
        if (localAudioTrack) previewStream.addTrack(localAudioTrack.mediaStreamTrack);
        if (localVideoTrack) previewStream.addTrack(localVideoTrack.mediaStreamTrack);
        preview.srcObject = previewStream;

        // Individual streams for recording
        audioStream = new MediaStream([localAudioTrack.mediaStreamTrack]);
        videoStream = new MediaStream([localVideoTrack.mediaStreamTrack]);

        // MediaRecorders
        const audioMime = 'audio/webm;codecs=opus';
        const videoMime = 'video/webm;codecs=vp8';
        audioRecorder = new MediaRecorder(audioStream, { mimeType: audioMime });
        videoRecorder = new MediaRecorder(videoStream, { mimeType: videoMime });

        const audioChunkMs = Math.max(200, parseInt(audioLenInput.value || "1000", 10));
        const videoChunkMs = Math.max(200, parseInt(videoLenInput.value || "1000", 10));

        audioRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size) {
            uploadChunk(e.data, `${serverBase}/upload/audio?sid=${encodeURIComponent(sid)}`);
          }
        };
        videoRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size) {
            uploadChunk(e.data, `${serverBase}/upload/video?sid=${encodeURIComponent(sid)}`);
          }
        };

        audioRecorder.start(audioChunkMs);
        videoRecorder.start(videoChunkMs);

        btnStop.disabled = false;
        btnMute.disabled = false;
        btnHide.disabled = false;
      } catch (err) {
        console.error(err);
        btnStart.disabled = false;
      }
    }

    const stop = () => {
      [audioRecorder, videoRecorder].forEach(r => {
        if (r && r.state !== "inactive") r.stop();
      });

      [localAudioTrack, localVideoTrack].forEach(t => t && t.stop());

      if (preview.srcObject) {
        preview.srcObject.getTracks().forEach(tr => tr.stop());
        preview.srcObject = null;
      }

      btnStart.disabled = false;
      btnStop.disabled = true;
      btnMute.disabled = true;
      btnHide.disabled = true;
      isMuted = false;
      isHidden = false;
      btnMute.textContent = "Mute Audio";
      btnHide.textContent = "Hide Video";
    }

    const toggleMute = () => {
      if (!localAudioTrack) return;
      isMuted = !isMuted;
      localAudioTrack.enable(!isMuted);
      btnMute.textContent = isMuted ? "Unmute Audio" : "Mute Audio";
    }

    const toggleHide = () => {
      if (!localVideoTrack) return;
      isHidden = !isHidden;
      localVideoTrack.enable(!isHidden);
      btnHide.textContent = isHidden ? "Show Video" : "Hide Video";
    }

    const uploadChunk = async (blob, url) => {
      try {
        const fd = new FormData();
        fd.append("chunk", blob, `part-${Date.now()}.webm`);
        await fetch(url, { method: "POST", body: fd });
      } catch (err) {
        console.error("Upload failed:", err);
        logServer("Upload failed (see console).");
      }
    }

    btnStart.onclick = start;
    btnStop.onclick  = stop;
    btnMute.onclick  = toggleMute;
    btnHide.onclick  = toggleHide;
  </script>
</body>
</html>
